// Implement the back end of the compiler which takes the three address code and produces the 8086 assembly language instructions that can be assembled and run using an 8086 assembler. The target assembly instructions can be simple move, add, sub, jump etc.

#include <stdio.h>

#include <string.h>

void main()
{
    char icode[10][30], str[20], opr[10];
    int i = 0;
    // clrscr();
    printf("\n Enter the set of intermediate code (terminated by exit):\n");
    do
    {
        scanf("%s", icode[i]);
    } while (strcmp(icode[i++], "exit") != 0);
    printf("\n target code generation");
    printf("\n************************");
    i = 0;
    do
    {
        strcpy(str, icode[i]);
        switch (str[3])
        {
        case '+':
            strcpy(opr, "ADD ");
            break;
        case '-':
            strcpy(opr, "SUB ");
            break;
        case '*':
            strcpy(opr, "MUL ");
            break;
        case '/':
            strcpy(opr, "DIV ");
            break;
        }
        printf("\n\tMov %c,R%d", str[2], i);
        printf("\n\t%s%c,R%d", opr, str[4], i);
        printf("\n\tMov R%d,%c", i, str[0]);
    } while (strcmp(icode[++i], "exit") != 0);
    // getch();
}
/* Here is the explanation for the code above:
1. The intermediate code is stored in icode array. We read the intermediate code from the user and store it in icode array.
2. We then read the intermediate code from the icode array and generate the target code.
3. The target code is generated in the following format:
Mov 2,R0
ADD 3,R0
Mov R0,1
4. The target code is generated by reading the intermediate code and extracting the operands and the operator and then generating the corresponding target code.
5. The target code is generated only for the simple arithmetic operations. We can extend the program to generate target code for other operations also.
6. The target code is generated for the registers R0, R1, R2, R3 and so on. We can extend the program to generate target code for other registers also. */
